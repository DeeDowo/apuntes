<h2 class="apunte__titulo-h2">
    Objetos en <span class="titulo-h2__span">JavaScript</span>
</h2>

<p class="apunte__parrafo">
    Un objeto es una colección de información relacionada, estos suelen incluir múltiples
    propiedades y funciones.
</p>

<p class="apunte__parrafo">La creación de un objeto es de la siguiente forma:</p>

<figure class="figure">
    <figcaption class="figure__titulo">Estructura básica de un objeto</figcaption>
    <pre class="codigo__bloque"><code>
const objeto = {
    miembro1nombre: miembro1valor,
    miembro2nombre: miembro2valor,
};</code></pre>
</figure>

<p class="apunte__parrafo">
    Con esta notación podemos crear objetos de cualquier complejidad. En el ejemplo
    anterior vemos que se declara como cualquier variable, pero es asignada a un par de
    llaves ({}), dentro de estas es donde se declara todo el contenido del objeto.
</p>

<p class="apunte__parrafo">
    Como podemos ver, dentro de un objeto cada "miembro" tiene un nombre y un valor,
    estos dos son separados por ":" y cada "miembro" con su respectivo valor es
    separado de otros con una ",". Los valores para los miembros pueden ser
    prácticamente cualquier cosa. Cuando se trata de un "data item",
    se llaman "propiedades". Cuando se trata de una función, se llaman "métodos".
</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo de un objeto en JavaScript</figcaption>
    <pre class="codigo__bloque"><code>
const persona = {
    nombre: ["dowo", "dowa"],
    edad: 24,
    bio: function (){
        console.log(`${this.nombre[0]} tiene ${this.edad} años.`);
    },
    introduceSelf: function(){
        console.log(`Hola! soy ${this.nombre[0]}.`);
    },
};</code></pre>
</figure>

<p class="apunte__parrafo">
    Con este código hemos creado un objeto, al que podemos acceder
    a sus propiedades y métodos por medio del
    nombre del objeto seguido de un "." seguido del nombre del miembro al que queremos acceder.
</p>

<p class="apunte__parrafo">
    Cuando se declara un método de un objeto, estos pueden tener una
    notación alternativa más compacta.
</p>

<p class="apunte__parrafo">
    Para el ejemplo visto esta sería la notación alternativa para la función
    "bio()" e "introduceSelf()", esta suele ser la forma más común de escribir un método:
</p>

<figure class="figure">
    <figcaption class="figure__titulo">Sintaxis alternativa para métodos</figcaption>
    <pre class="codigo__bloque">
...
bio(){
    console.log(...);
},
introduceSelf(){
    console.log(...);
}
...</pre>
</figure>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo accediendo a miembros de un objeto</figcaption>
    <pre class="codigo__bloque"><code>
console.log(persona.nombre[0]);
persona.bio();</code></pre>
</figure>

<p class="apunte__parrafo">
    Un objeto como el del ejemplo es llamado "object literal", ya que escribimos
    el contenido conforme lo creamos.
</p>

<p class="apunte__parrafo">
    Es común la creación de un "object literal" al querer transferir
    información relacionada y ordenada. Por ejemplo, al enviar una solicitud
    a un servidor para ser almacenada en una base de datos, el enviar objetos
    es más eficiente que enviar la información por separado al igual que es más sencillo
    trabajar con objetos.
</p>

<h3 class="apunte__titulo-h3">Dot notation</h3>

<p class="apunte__parrafo">
    La notación para acceder a las propiedades de un objeto o a sus métodos
    es llamada "dot notation", esta hace referencia a agregar un "." entre el nombre del
    objeto y la propiedad o método. El nombre del objeto es indispensable para
    poder acceder a la información dentro de este.
</p>

<h3 class="apunte__titulo-h3">Objetos como propiedades</h3>

<p class="apunte__parrafo">Una propiedad de un objeto puede ser a su vez otro objeto</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo objetos anidados</figcaption>
    <pre class="codigo__bloque"><code>
const persona = {
    nombres: {
        nombre1: "dowo",
        nombre2: "dowa",
    },
};</code></pre>
</figure>

<p class="apunte__parrafo">Para acceder a estas propiedades anidadas, solo hay que encadenar los múltiples objetos de la
    siguiente forma:</p>
<ul class="lista-desordenada">
    <li class="lista-desordenada__elemento">
        persona.nombres.nombre1;
    </li>
    <li class="lista-desordenada__elemento">
        persona.nombres.nombre2;
    </li>
</ul>

<h3 class="apunte__titulo-h3">Bracket notation</h3>

<p class="apunte__parrafo">Esta es una forma alternativa a la "dot notation" para acceder a las propiedades y métodos de
    los objetos.</p>

<ul class="lista-desordenada">
    <li class="lista-desordenada__elemento">
        persona["edad"];
    </li>
    <li class="lista-desordenada__elemento">
        persona["nombres"]["nombre1"];
    </li>
</ul>

<p class="apunte__parrafo">
    Esta notación es bastante similar a la forma en que se ingresa a un elemento de un
    array. En lugar de usar un índice, se utiliza el nombre de la propiedad o método envuelto entre comillas,
    por esta similitud es que los objetos pueden ser llamados "associative arrays".
</p>

<h3 class="apunte__titulo-h3">Qué notación utilizar</h3>

<p class="apunte__parrafo">
    La "dot notation" sigue siendo preferida sobre la "bracket notation" ya que es más
    simple y fácil de leer.
</p>

<p class="apunte__parrafo">
    Sin embargo, existen situaciones donde no es posible
    utilizar la "dot notation". Un ejemplo es cuando el nombre de una propiedad es
    guardada en una variable con un nombre diferente a este. Si utilizamos la "dot
    notation" con el nombre de esta variable, se buscará una propiedad con este
    nombre literal y no el del valor guardado en la variable. Pero si utilizamos
    la "bracket notation", notaremos que funciona sin
    ningún problema, ya que esta sí utiliza el valor guardado en la variable.
</p>

<ul class="lista-desordenada">
    <li class="lista-desordenada__elemento">
        persona.variable; (buscará una propiedad en el objeto persona con el nombre "variable")
    </li>
    <li class="lista-desordenada__elemento">
        persona[variable]; (buscará una propiedad en el objeto persona con el nombre guardado en la variable)
    </li>
</ul>

<h3 class="apunte__titulo-h3">Miembros de un objeto</h3>

<p class="apunte__parrafo">
    Hasta ahora solo hemos visto cómo obtener información del objeto, pero también
    es posible modificar esta información. Esto se realiza seleccionando el miembro a modificar
    por medio de la "dot notation" o "bracket notation" y asignándole el nuevo valor.
</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo modificando el valor de una propiedad</figcaption>
    <pre class="codigo__bloque"><code>
persona.edad = 44;
persona["nombres"]["nombre1"] = "si";</code></pre>
</figure>

<p class="apunte__parrafo">Ahora si volvemos a "llamar" a estas propiedades obtendremos los nuevos valores.</p>

<p class="apunte__parrafo">
    También podemos agregar
    propiedades o métodos completamente nuevos a estos objetos simplemente declarando nuevos
    nombres para estos miembros.
</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo agregando propiedades nuevas</figcaption>
    <pre class="codigo__bloque"><code>
persona.ojos = "cafe"; 
persona.dobleEdad = function(){
    console.log(this.edad*2);
};</code></pre>
</figure>

<p class="apunte__parrafo">
    Un aspecto útil de la "bracket notation" es que se pueden agregar
    propiedades, funciones o valores tomando como referencia una variable,
    es decir:
</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo agregando propiedad nuevas (bracket notation)</figcaption>
    <pre class="codigo__bloque"><code>
const myDataName = "altura";
const myDataValue = "1.65";

persona[myDataName] = myDataValue;</code></pre>
</figure>

<h3 class="apunte__titulo-h3">Qué es "this"?</h3>

<p class="apunte__parrafo">
    Esta es una palabra clave que hace referencia al propio objeto en el
    que se encuentra, esto es especialmente útil en los "constructors".
</p>

<h3 class="apunte__titulo-h3">Constructors</h3>

<p class="apunte__parrafo">
    Usar "object literals" está bien para cuando solo se necesita crear un
    objeto, pero cuando se necesitan crear más de uno no es eficiente, ya que
    para agregar propiedades o métodos, cada una de estas declaraciones de
    "object literals" tendrían que ser actualizadas una por una. Lo
    que se suele hacer es crear una especie de "plantilla".
</p>

<p class="apunte__parrafo">La primera versión de esto es solamente una función, un ejemplo sería:</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo función como constructor</figcaption>
    <pre class="codigo__bloque"><code>
function createPerson(nombre){
    const obj = {};
    obj.nombre = nombre;
    obj.introduceSelf = function () {
        console.log(`Hola! Mi nombre es ${this.nombre}`);
    };

    return obj;
}</code></pre>
</figure>

<p class="apunte__parrafo">En el ejemplo, esta función crea y devuelve un nuevo objeto cada vez que la llamamos, este
    objeto tendrá dos miembros.</p>

<ul class="lista-desordenada">
    <li class="lista-desordenada__elemento">
        La propiedad "nombre".
    </li>
    <li class="lista-desordenada__elemento">
        El método "introduceSelf()".
    </li>
</ul>

<p class="apunte__parrafo">
    Esta "plantilla" solo toma como parámetro un "nombre" para definir las diferentes
    propiedades y métodos de este objeto. Una vez creada podemos usarla tantas
    veces como queramos.
</p>

<p class="apunte__parrafo">
    Podemos crear n cantidad de objetos con esta plantilla. Esto funciona bien,
    pero hay una forma más sencilla: usando un "constructor". Los "constructors" son
    solo una función a la cual llamamos utilizando la palabra clave "new". Cuando
    llamamos a un "constructor" sucede lo siguiente:
</p>

<ol class="lista-ordenada lista-desordenada">
    <li class="lista-ordenada__elemento lista-desordenada__elemento">
        Se crea un nuevo objeto temporal.
    </li>
    <li class="lista-ordenada__elemento lista-desordenada__elemento">
        Los "this" en el constructor son "reemplazados" por el objeto temporal.
    </li>
    <li class="lista-ordenada__elemento lista-desordenada__elemento">
        Una vez finalizado todo el proceso del constructor, este "objTemp" es
        devuelto y asignado a la variable donde lo hayamos inicializado.
    </li>
</ol>

<p class="apunte__parrafo">
    La palabra clave "this" al usarse dentro un objeto
    hace referencia a miembros en el mismo objeto.
</p>

<p class="apunte__parrafo">
    Por convención, los nombres de los "constructors" inician con
    mayúsculas y son nombrados por el tipo de objeto que crean, por ejemplo:
</p>

<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo constructor</figcaption>
    <pre class="codigo__bloque"><code>
function Persona(nombre){
    this.nombre = nombre;
    this.saludo = function (){
        console.log(`Hola! mi nombre es ${this.nombre}.`);
    };
}</code></pre>
</figure>

<p class="apunte__parrafo">
    La diferencia entre un constructor y una función es que en el constructor no es necesario crear un objeto
    temporal explícitamente y en este se hace uso de la palabra clave "this".
</p>