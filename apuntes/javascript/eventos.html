<h2 class="apunte__titulo-h2">
    Eventos
</h2>
<p class="apunte__parrafo">
    Los eventos son cosas que suceden en el sistema, este mismo nos
    dice acerca de ellos para que de esta forma nuestro código pueda reaccionar a estos. Por ejemplo, algo típico en
    JavaScript es reaccionar a
    cuando el usuario hace clic en un botón.
</p>
<p class="apunte__parrafo">
    Los eventos suceden o se "disparan" cuando una señal de algún tipo ocurre,
    el propio sistema provee de un mecanismo para poder ejecutar algún código cuando estas
    señales ocurren. Algunos ejemplos son:
</p>
<ul class="lista-desordenada">
    <li class="lista-desordenada__elemento">
        El usuario selecciona, hace "clic" o "sobrevuela" un cierto elemento.
    </li>
    <li class="lista-desordenada__elemento">
        El usuario presiona una tecla en el teclado.
    </li>
    <li class="lista-desordenada__elemento">
        El usuario redimensiona una ventana.
    </li>
    <li class="lista-desordenada__elemento">
        Una página web termina de cargarse.
    </li>
    <li class="lista-desordenada__elemento">
        Un formulario es enviado.
    </li>
    <li class="lista-desordenada__elemento">
        Un video es reproducido, pausado o finalizado.
    </li>
    <li class="lista-desordenada__elemento">
        Algún error ocurre.
    </li>
</ul>
<p class="apunte__parrafo">
    Para poder reaccionar a un evento, se tiene que asignar un controlador de eventos ("event handler")
    a estos. Esto en esencia es un bloque de código (usualmente una función que nosotros creamos) que se
    ejecuta cuando un evento se dispara. Cuando un bloque de código es definido para ejecutarse en
    respuesta a un evento, decimos que estamos registrando un controlador de eventos.
</p>
<p class="apunte__parrafo">
    Los "event handlers" a veces son llamados también "event listeners", sin embargo, hablando de
    forma técnica, en realidad estas son dos partes que trabajan juntas. El "listener"
    "escucha" los eventos y el "handler" es el código que responde a lo que "escucha" el "listener".
</p>
<p class="apunte__parrafo">
    Los "web events" no son parte de JavaScript en sí mismos, estos son definidos
    por parte de las APIs precargadas en el navegador.
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo Evento</figcaption>
    <pre class="codigo__bloque"><code>
const btn = document.querySelector("button");

function random(number){
    return Math.floor(Math.random() * (number + 1));
}

btn.addEventListener("click", () => {
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    document.body.style.backgroundColor = rndCol;
});</code></pre>
</figure>
<p class="apunte__parrafo">
    En este ejemplo tenemos un botón que al presionarlo, hace que el color de fondo de la página cambie. Las partes de
    este son:
</p>
<ol class="lista-ordenada lista-desordenada">
    <li class="lista-ordenada__elemento lista-desordenada__elemento">
        El elemento HTML &lt;button&gt; disparará un evento cuando el usuario haga "clic" sobre
        este, entonces definimos un "addEventListener()" y a este método le pasamos dos parámetros.
    </li>
    <li class="lista-ordenada__elemento lista-desordenada__elemento">
        El string "click", indica que queremos "escuchar" un evento "click". Los botones pueden
        disparar diferentes eventos, un par de ejemplos son "mouseover", para cuando el usuario mueve el
        mouse sobre un botón o "keydown", para cuando el usuario utiliza una tecla de navegación y el botón es
        seleccionado.
    </li>
    <li class="lista-ordenada__elemento lista-desordenada__elemento">
        Una función que se ejecuta cuando el evento descrito en el parámetro anterior sucede, en este
        caso ocupamos una función anónima para generar un color aleatorio usando la función RGB y
        aplicar este al "backgroundColor" de la página. La función puede o no ser anónima.
    </li>
</ol>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo Evento sin función anónima</figcaption>
    <pre class="codigo__bloque"><code>
const btn = document.querySelector("button");

function random(number){
    return Math.floor(Math.random() * (number + 1));
}

function changeBackground(){
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    document.body.style.backgroundColor = rndCol;
}

btn.addEventListener("click", changeBackground);</code></pre>
</figure>
<h3 class="apunte__titulo-h3">
    addEventListener()
</h3>
<p class="apunte__parrafo">
    El método "addEventListener()" es el mecanismo recomendado para agregar controladores de eventos.
</p>
<h4 class="apunte__titulo-h4">
    Algunos eventos comunes
</h4>
<dl class="lista-descriptiva">
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            Focus y Blur
        </dt>
        <dd class="lista-descriptiva__descripcion">
            Los eventos "focus" y "blur" suelen usarse en conjunto. Sirven para cuando un elemento es "seleccionado" o
            "deseleccionado".
            Generalmente son utilizados en campos de entrada para indicar qué ingresar o indicar algún
            error de formato por mencionar algunos ejemplos.
        </dd>
    </div>
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            Dblclick
        </dt>
        <dd class="lista-descriptiva__descripcion">
            El evento "dblclick" se utiliza para "escuchar" un doble "clic" sobre algún elemento. Generalmente se
            utiliza en botones.
        </dd>
    </div>
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            "mouseover" y "mouseout"
        </dt>
        <dd class="lista-descriptiva__descripcion">
            Los eventos "mouseover" y "mouseout" suelen usarse en conjunto. Sirven para cuando el mouse "sobrevuela" un
            elemento y
            para cuando el mouse deja de "sobrevolar" el elemento.
        </dd>
    </div>
</dl>
<p class="apunte__parrafo">
    Los eventos tienen su propia clasificación, es decir, existen algunos eventos que están disponibles en prácticamente
    todos los elementos, mientras
    que existen otros que son más específicos y que solamente sirven para ciertos
    elementos. Por ejemplo, "play", este evento solo está disponible para elementos como video o audio.
</p>
<h3 class="apunte__titulo-h3">
    removeEventListener()
</h3>
<p class="apunte__parrafo">
    Como su nombre indica, este método es la contraparte de "addEventListener",
    este sirve para remover algún evento, es decir, que una vez ejecutado un "removeEventListener()"
    tratamos de volver a ejecutar el "addEventListener()", este no funcionará ya que ya no existirá.
</p>
<p class="apunte__parrafo">
    La utilidad de "removeEventListener" es que esto puede mejorar la eficiencia cuando se tiene
    un exceso de "addEventListener()".
</p>
<p class="apunte__parrafo">
    Otra forma de remover "addEventListener" es pasando una "AbortSignal" a los "addEventListener()" y después
    en el código llamar la función "abort()" en el controlador de la "AbortSignal".
</p>
<h3 class="apunte__titulo-h3">
    Múltiples "addEventListener()" a un solo elemento
</h3>
<p class="apunte__parrafo">
    El agregar múltiples "addEventListener()" a un mismo elemento, es una práctica común para hacer que este
    reaccione de múltiples formas a un mismo evento.
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo múltiples addEventListener()</figcaption>
    <pre class="codigo__bloque">
elemento.addEventListener("click", función1);
elemento.addEventListener("click", función2);</pre>
</figure>
<h3 class="apunte__titulo-h3">
    Otros mecanismos para "escuchar" eventos
</h3>
<p class="apunte__parrafo">
    "addEventListener()" es lo recomendable para registrar diferentes "events handlers",
    es el método más poderoso y escala de una buena forma con programas más complejos, sin
    embargo, existen otras dos formas para registrar estos eventos.
</p>
<dl class="lista-descriptiva">
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            Event handler properties
        </dt>
        <dd class="lista-descriptiva__descripcion">
            Algunos objetos tienen propiedades con el prefijo "on" seguido del nombre del evento. Por ejemplo, para
            botones
            tenemos la propiedad "onclick", que se activa cuando se hace "clic" en él, esta es llamada una "event
            handler property",
            para usar esta hay que asignar la función al elemento con esta propiedad. Se puede usar tanto una función de
            flecha como una normal.
            <figure class="figure">
                <figcaption class="figure__titulo">Ejemplo "event handler property" con función de flecha</figcaption>
                <pre class="codigo__bloque"><code>
btn.onclick = () => {
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    document.body.style.backgroundColor = rndCol;
};</code></pre>
            </figure>
        </dd>
        <dd class="lista-descriptiva__descripcion">
            A diferencia de "addEventListener()", no se pueden agregar múltiples "event handler properties"
            a un mismo elemento, esto sucede ya que cualquier función
            asignada al final, sobrescribirá todas las asignaciones anteriores.
            <figure class="figure">
                <figcaption class="figure__titulo">Ejemplo "event handler properties" sobrescritura</figcaption>
                <pre class="codigo__bloque"><span>
elemento.onclick = función1;
elemento.onclick = función2;</span></pre>
            </figure>
        </dd>
    </div>
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            Inline event handlers
        </dt>
        <dd class="lista-descriptiva__descripcion">
            Los "inline event handlers" se agregan directamente en el documento HTML, es el
            método más primitivo para registrar eventos y actualmente considerado una mala práctica,
            principalmente porque al igual que lo visto previamente con HTML y CSS, no es
            bueno combinar semántica (HTML) con estilos (CSS) con funcionalidad (JS) en el mismo
            documento. La mejor práctica es mantener los diferentes elementos proporcionados por
            los diferentes lenguajes en diferentes archivos. Por lo general la mayoría de
            servidores desactivarán el "inline JavaScript" como medida de seguridad.
        </dd>
    </div>
</dl>
<h3 class="apunte__titulo-h3">
    Objetos de eventos
</h3>
<p class="apunte__parrafo">
    Algunas veces, dentro de una "event handler function", existirá la presencia de
    un parámetro con el nombre "event", "evt" o "e". Este es llamado el "event object", es
    "pasado" de forma automática al "event handler" para proveer información y características extras.
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo Event object</figcaption>
    <pre class="codigo__bloque"><code>
const btn = document.querySelector("button");

function random(number){
    return Math.floor(Math.random() * (number + 1));
}

function bgChange(e){
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    e.target.style.backgroundColor = rndCol;
}

btn.addEventListener("click", bgChange);</code></pre>
</figure>
<p class="apunte__parrafo">
    En este ejemplo estamos modificando el elemento "e.target", el cual es el propio botón,
    la propiedad "target" del evento es siempre una referencia al elemento en donde está
    sucediendo el evento. En este ejemplo, el fondo aleatorio ocurre en el botón, no en la página.
</p>
<p class="apunte__parrafo">
    Es posible usar cualquier nombre posible para el "event object", sin embargo, la práctica
    más común es utilizar "e", "evt" o "event". Una vez elegido un nombre, solo hay que ser consistente con este.
</p>
<h3 class="apunte__titulo-h3">
    Propiedades extras para el event object
</h3>
<p class="apunte__parrafo">
    La mayoría de "event objects" tienen un set estándar de propiedades y métodos disponibles,
    algunos "event objects" tienen propiedades extra, relevantes para ese tipo de evento en
    particular. Por ejemplo, los eventos "keydown" que se disparan cuando el usuario presiona
    alguna tecla, el "event object" de este tiene una propiedad especial, "key", la cual indica qué tecla fue
    presionada.
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo "key"</figcaption>
    <pre class="codigo__bloque"><code>
const textBox = document.querySelector("#textbox");
const output = document.querySelector("#output");

textBox.addEventListener("keydown", (event) => {
    output.textContent = `Presionaste "${event.key}".`;
});</code></pre>
</figure>
<h3 class="apunte__titulo-h3">
    Previniendo comportamiento "por defecto"
</h3>
<p class="apunte__parrafo">
    El método "preventDefault()" hace referencia a cuando queremos que algo ignore su comportamiento por defecto.
</p>
<p class="apunte__parrafo">
    El ejemplo más común es con formularios. Por defecto, al llenar un formulario y hacer
    "clic" en el botón "submit", la información será enviada a una página especificada
    para su procesamiento. El problema ocurre cuando el usuario ha llenado de forma incorrecta el formulario,
    como desarrollador, uno de nuestros trabajos es evitar que estos errores se manden al servidor.
    Para prevenir esto se envía un mensaje de error al usuario diciéndole en dónde está el error
    y qué se necesita corregir para solucionar dicho error.
</p>
<p class="apunte__parrafo">
    Algunos navegadores realizan verificaciones
    de forma automática, pero otros no, por ende es recomendable implementar nuestras propias verificaciones siempre.
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo preventDefault()</figcaption>
    <pre class="codigo__bloque"><code>
const form = document.querySelector("form");
const fname = document.getElementById("fname");
const lname = document.getElementById("lname");
const para = document.querySelector("p");

form.addEventListener("submit", (e) => {
    if (fname.value === "" || lname.value === ""){
        e.preventDefault();
        para.textContent = "Necesita ingresar nombre y apellido";
    }
});</code></pre>
</figure>
<p class="apunte__parrafo">
    En este ejemplo el punto más importante es el uso de "e.preventDefault()", este método como
    su nombre indica, evita el comportamiento "por defecto", en este caso, el enviar el formulario.
</p>
<p class="apunte__parrafo">
    Algo a considerar es que los eventos no son únicos de JavaScript, la mayoría de lenguajes de programación tienen
    algún
    tipo de "event model", al igual que su propia metodología del cómo funcionan estos. Generalmente
    diferente a JavaScript. De hecho, el propio modelo para eventos en JavaScript en páginas web es diferente al
    modelo usado en otros entornos derivados de JavaScript.
</p>
<h3 class="apunte__titulo-h3">
    Event bubbling
</h3>
<p class="apunte__parrafo">
    Hasta ahora hemos visto cómo una web está compuesta por diferentes elementos y que
    podemos "escuchar" eventos en estos. Por ejemplo, ejecutar un código cuando el
    usuario haga "clic" en un botón.
    Una vez entendido eso podemos ver el "event bubbling", esto hace referencia al cómo se "dispersan" los eventos.
</p>
<p class="apunte__parrafo">
    Considerando una página con la siguiente estructura:
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo "event bubbling"</figcaption>
    <pre class="codigo__bloque"><code>
&lt;div id="container"&gt;
    &lt;button&gt;Click&lt;/button&gt;
&lt;/div&gt;

&lt;pre id="output"&gt;&lt;/pre&gt;</code></pre>
</figure>
<p class="apunte__parrafo">
    Teniendo un botón dentro de un elemento "div", podemos decir que el
    elemento "div" es "padre" del elemento "button".
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo event bubbling</figcaption>
    <pre class="codigo__bloque"><code>
const output = document.querySelector("#output");

function handleClick(e){
    output.textContent += `Hiciste clic en un elemento ${e.currentTarget.tagName}\n`;
}

const container = document.querySelector("#container");
container.addEventListener("click", handleClick);</code></pre>
</figure>
<p class="apunte__parrafo">
    En este ejemplo podemos ver cómo al hacer "clic" en el botón, esto dispara
    un evento definido en el elemento "padre", el "div".
</p>
<p class="apunte__parrafo">
    Si agregamos un "event listener" también al botón como al elemento padre del propio "div",
    veremos que los tres disparan el evento "click", en orden ascendente, es decir,
    primero en el botón, luego en el "div" y por último en el "padre" del div, a este
    comportamiento se le llama "bubbles up". Esto es algo que
    puede resultar útil, pero a la vez puede generar problemas inesperados, ya que
    si tenemos un mismo tipo de "event listener" para múltiples elementos anidados, uno solo dispararía todos.
</p>
<h3 class="apunte__titulo-h3">
    Arreglando el problema con "stopPropagation()"
</h3>
<p class="apunte__parrafo">
    "stopPropagation()" es un método disponible para los "event objects",
    esta al ser declarada dentro de un "event handler" evita la propagación
    del evento como su nombre lo indica, esta debe ser la primera expresión en el "event handler".
</p>
<h3 class="apunte__titulo-h3">
    Captura de eventos
</h3>
<p class="apunte__parrafo">
    Una forma alternativa de "event propagation" es "event capture". Se podría
    decir que es la inversa de "event bubbling", es decir, en lugar de propagarse
    desde el elemento más anidado, se propaga desde el elemento "menos anidado"
    o el elemento "padre" hasta llegar al elemento más anidado. "Event
    capture" está deshabilitado por defecto, para poder activarlo se tiene que
    pasar como parámetro en la función "addEventListener()" de la siguiente forma:
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Activando "event capture"</figcaption>
    <pre class="codigo__bloque">
elemento.addEventListener("click", función, {capture: true}){
    ...código...
}</pre>
</figure>
<p class="apunte__parrafo">
    Por defecto, la gran mayoría de "event handlers" registran eventos de la
    forma "bubbles up" ya que es lo que hace sentido la mayoría de las veces.
</p>
<h3 class="apunte__titulo-h3">
    Delegación de eventos
</h3>
<p class="apunte__parrafo">
    El "event bubbling" puede parecer molesto, pero en varias ocasiones este
    comportamiento puede resultar útil, en particular porque permite el "event delegation", es decir,
    que un elemento diferente al que queremos agregar algún
    comportamiento se haga cargo de manejar este comportamiento.
</p>
<p class="apunte__parrafo">
    Por ejemplo,
    cuando queremos que un cierto código se ejecute al interactuar con cualquiera
    de los "hijos" de un elemento, podemos definir un "event listener" en el elemento
    "padre" para que cuando el evento llegue a él a causa del "bubbling up", este se
    haga cargo del comportamiento, de esta forma evitamos tener que indicar un
    comportamiento a cada uno de los elementos "hijos" de manera individual.
</p>
<figure class="figure">
    <figcaption class="figure__titulo">Ejemplo "Event delegation"</figcaption>
    <pre class="codigo__bloque"><code>
function random(number){
    return Math.floor(Math.random() * (number + 1));
}

function bgChange(){
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    return rndCol;
}

const container = document.querySelector("#container");

container.addEventListener("click", (event) => {
    event.target.style.backgroundColor = bgChange();
});</code></pre>
</figure>
<p class="apunte__parrafo">
    La parte más importante y referente a este tema en el ejemplo es el "event.target",
    esta es la parte que se encargará de seleccionar el elemento de origen del
    evento, en este caso el "hijo" en donde se originó el "clic" y aplicar el código en dicho elemento.
</p>
<p class="apunte__parrafo">
    Si quisiéramos en este ejemplo modificar al elemento padre, podríamos usar
    "event.currentTarget", el cual como su nombre indica, hace referencia al
    elemento actual donde se "escuchó" el evento incluso si este no es el origen.
</p>
<dl class="lista-descriptiva">
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            Target
        </dt>
        <dd class="lista-descriptiva__descripcion">
            Fijo. Se refiere al origen del evento.
        </dd>
    </div>
    <div class="lista-descriptiva__bloque">
        <dt class="lista-descriptiva__titulo">
            CurrentTarget
        </dt>
        <dd class="lista-descriptiva__descripcion">
            Variable. Se refiere a en qué punto de dispersión está el evento.
        </dd>
    </div>
</dl>
<p class="apunte__parrafo">
    La propiedad "target" suele ser utilizada principalmente al
    delegar un evento (event delegation).
</p>